(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Subject'), require('@angular/common')) :
	typeof define === 'function' && define.amd ? define('ngx-drag-and-drop-lists', ['exports', '@angular/core', 'rxjs/Subject', '@angular/common'], factory) :
	(factory((global['ngx-drag-and-drop-lists'] = {}),global.ng.core,global.Rx,global.ng.common));
}(this, (function (exports,core,Subject,common) { 'use strict';

var MIME_TYPE = 'application/x-dnd';
var EDGE_MIME_TYPE = 'application/json';
var MSIE_MIME_TYPE = 'Text';
var ALL_EFFECTS = ['move', 'copy', 'link'];
var DndState = /** @class */ (function () {
    function DndState() {
        this.dragState = {
            isDragging: false,
            itemType: undefined,
            dropEffect: 'none',
            effectAllowed: ALL_EFFECTS[0],
        };
    }
    DndState.prototype.filterEffects = function (effects, effectAllowed) {
        if (effectAllowed === 'all')
            return effects;
        return effects.filter(function (effect) {
            return effectAllowed.toLowerCase().indexOf(effect) !== -1;
        });
    };
    return DndState;
}());
DndState.decorators = [
    { type: core.Injectable },
];
var dropAccepted = new Subject.Subject();
var DndList = /** @class */ (function () {
    function DndList(element, dndState) {
        this.element = element;
        this.dndState = dndState;
        this.option = {
            disabled: false,
            effectAllowed: 'move',
            allowedTypes: undefined,
        };
        this.dndDragOver = new core.EventEmitter();
        this.dndDrop = new core.EventEmitter();
        this.dndInserted = new core.EventEmitter();
        this.listSettings = {};
        this.dragState = dndState.dragState;
        this.nativeElement = element.nativeElement;
        this.placeholder = this.getPlaceholderElement();
    }
    Object.defineProperty(DndList.prototype, "dndPlaceholder", {
        set: function (placeholder) {
            this.placeholder = placeholder;
            placeholder.remove();
        },
        enumerable: true,
        configurable: true
    });
    DndList.prototype.ngOnInit = function () {
    };
    DndList.prototype.ngOnDestroy = function () {
    };
    DndList.prototype.handleDragEnter = function (event) {
        event = event['originalEvent'] || event;
        var mimeType = this.getMimeType(event.dataTransfer.types);
        if (!mimeType || !this.isDropAllowed(this.getItemType(mimeType))) {
            return true;
        }
        event.preventDefault();
        return false;
    };
    DndList.prototype.handleDragOver = function (event) {
        event = event['originalEvent'] || event;
        var mimeType = this.getMimeType(event.dataTransfer.types);
        var itemType = this.getItemType(mimeType);
        if (!mimeType || !this.isDropAllowed(itemType)) {
            return true;
        }
        if (this.placeholder.parentNode !== this.nativeElement) {
            this.nativeElement.appendChild(this.placeholder);
        }
        if (event.target !== this.nativeElement) {
            var listItemNode = (event.target);
            while (listItemNode.parentNode !== this.nativeElement && listItemNode.parentNode) {
                listItemNode = listItemNode.parentNode;
            }
            if (listItemNode.parentNode === this.nativeElement && listItemNode !== this.placeholder) {
                var isFirstHalf = void 0;
                var rect = ((listItemNode)).getBoundingClientRect();
                if (this.option && this.option.horizontal) {
                    isFirstHalf = event.clientX < rect.left + rect.width / 2;
                }
                else {
                    isFirstHalf = event.clientY < rect.top + rect.height / 2;
                }
                this.nativeElement.insertBefore(this.placeholder, isFirstHalf ? listItemNode : listItemNode.nextSibling);
            }
        }
        var ignoreDataTransfer = mimeType === MSIE_MIME_TYPE;
        var dropEffect = this.getDropEffect(event, ignoreDataTransfer);
        if (dropEffect === 'none')
            return this.stopDragOver();
        event.preventDefault();
        if (!ignoreDataTransfer) {
            event.dataTransfer.dropEffect = dropEffect;
        }
        this.nativeElement.classList.add('dndDragover');
        event.stopPropagation();
        return false;
    };
    DndList.prototype.handleDrop = function (event) {
        event = event['originalEvent'] || event;
        var mimeType = this.getMimeType(event.dataTransfer.types);
        var itemType = this.getItemType(mimeType);
        if (!mimeType || !this.isDropAllowed(itemType))
            return true;
        event.preventDefault();
        var data = undefined;
        try {
            data = JSON.parse(event.dataTransfer.getData(mimeType));
        }
        catch (e) {
            return this.stopDragOver();
        }
        if (mimeType === MSIE_MIME_TYPE || mimeType === EDGE_MIME_TYPE) {
            itemType = data.type || undefined;
            data = data.item;
            if (!this.isDropAllowed(itemType))
                return this.stopDragOver();
        }
        var ignoreDataTransfer = mimeType === MSIE_MIME_TYPE;
        var dropEffect = this.getDropEffect(event, ignoreDataTransfer);
        if (dropEffect === 'none')
            return this.stopDragOver();
        var index = this.getPlaceholderIndex();
        var offset = this.nativeElement.children.length - 1 - this.dndModel.length;
        if (this.dndDrop) {
            this.invokeCallback(this.dndDrop, event, dropEffect, itemType, index, data);
            if (!data)
                return this.stopDragOver();
        }
        this.dragState.dropEffect = dropEffect;
        if (!ignoreDataTransfer) {
            event.dataTransfer.dropEffect = dropEffect;
        }
        if (data !== true) {
            var insertionPoint = index - offset;
            if (insertionPoint < 0) {
                insertionPoint = 0;
            }
            this.dndModel.splice(insertionPoint, 0, data);
        }
        this.invokeCallback(this.dndInserted, event, dropEffect, itemType, index, data);
        dropAccepted.next({ item: data, list: this.dndModel });
        this.stopDragOver();
        event.stopPropagation();
        return false;
    };
    DndList.prototype.handleDragLeave = function (event) {
        event = event['originalEvent'] || event;
        var newTarget = document.elementFromPoint(event.clientX, event.clientY);
        if (this.nativeElement.contains(newTarget) && !event['_dndPhShown']) {
            event['_dndPhShown'] = true;
        }
        else {
            this.stopDragOver();
        }
    };
    DndList.prototype.getPlaceholderElement = function () {
        var placeholder = undefined;
        if (this.nativeElement.children) {
            for (var i = 1; i < this.nativeElement.children.length; i++) {
                var child = this.nativeElement.children.item(i);
                if (child.classList.contains('dndPlaceholder')) {
                    placeholder = child;
                }
            }
        }
        var placeholderDefault = document.createElement('li');
        placeholderDefault.classList.add('dndPlaceholder');
        return placeholder || placeholderDefault;
    };
    DndList.prototype.getMimeType = function (types) {
        if (!types)
            return MSIE_MIME_TYPE;
        for (var i = 0; i < types.length; i++) {
            if (types[i] === MSIE_MIME_TYPE || types[i] === EDGE_MIME_TYPE ||
                types[i].substr(0, MIME_TYPE.length) === MIME_TYPE) {
                return types[i];
            }
        }
        return null;
    };
    DndList.prototype.getItemType = function (mimeType) {
        if (this.dragState.isDragging)
            return this.dragState.itemType || undefined;
        if (mimeType === MSIE_MIME_TYPE || mimeType === EDGE_MIME_TYPE)
            return null;
        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;
    };
    DndList.prototype.isDropAllowed = function (itemType) {
        if (this.option) {
            if (this.option.disabled)
                return false;
            if (this.option.max && this.dndModel.length === this.option.max)
                return false;
            if (!this.option.externalSources && !this.dragState.isDragging)
                return false;
            if (!this.option.allowedTypes || itemType === null)
                return true;
        }
        return itemType && this.option.allowedTypes.indexOf(itemType) !== -1;
    };
    DndList.prototype.getDropEffect = function (event, ignoreDataTransfer) {
        var effects = Object.assign([], ALL_EFFECTS);
        if (!ignoreDataTransfer) {
            effects = this.dndState.filterEffects(effects, event.dataTransfer.effectAllowed);
        }
        if (this.dragState.isDragging) {
            effects = this.dndState.filterEffects(effects, this.dragState.effectAllowed);
        }
        if (this.option && this.option.effectAllowed) {
            effects = this.dndState.filterEffects(effects, this.option.effectAllowed);
        }
        if (!effects.length) {
            return 'none';
        }
        else if (event.ctrlKey && effects.indexOf('copy') !== -1) {
            return 'copy';
        }
        else if (event.altKey && effects.indexOf('link') !== -1) {
            return 'link';
        }
        else {
            return effects[0];
        }
    };
    DndList.prototype.stopDragOver = function () {
        this.placeholder.remove();
        this.nativeElement.classList.remove('dndDragover');
        return true;
    };
    DndList.prototype.invokeCallback = function (eventEmitter, event, dropEffect, itemType, index, item) {
        eventEmitter.emit({
            dropEffect: dropEffect,
            event: event,
            external: !this.dragState.isDragging,
            index: index !== undefined ? index : this.getPlaceholderIndex(),
            item: item || undefined,
            type: itemType,
        });
        return true;
    };
    DndList.prototype.getPlaceholderIndex = function () {
        for (var i = 0; i < this.nativeElement.children.length; i++) {
            if (this.nativeElement.children[i].classList.contains('dndDragging')) {
                this.nativeElement.children[i].remove();
                break;
            }
        }
        return Array.prototype.indexOf.call(this.nativeElement.children, this.placeholder);
    };
    return DndList;
}());
DndList.decorators = [
    { type: core.Directive, args: [{
                selector: '[dndList]',
            },] },
];
DndList.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: DndState, },
]; };
DndList.propDecorators = {
    "option": [{ type: core.Input, args: ['dndList',] },],
    "dndModel": [{ type: core.Input, args: ['dndModel',] },],
    "dndPlaceholder": [{ type: core.Input },],
    "dndDragOver": [{ type: core.Output, args: ['dndDragOver',] },],
    "dndDrop": [{ type: core.Output, args: ['dndDrop',] },],
    "dndInserted": [{ type: core.Output, args: ['dndInserted',] },],
    "handleDragEnter": [{ type: core.HostListener, args: ['dragenter', ['$event'],] },],
    "handleDragOver": [{ type: core.HostListener, args: ['dragover', ['$event'],] },],
    "handleDrop": [{ type: core.HostListener, args: ['drop', ['$event'],] },],
    "handleDragLeave": [{ type: core.HostListener, args: ['dragleave', ['$event'],] },],
};
var DndDraggable = /** @class */ (function () {
    function DndDraggable(element, dndState) {
        this.element = element;
        this.dndState = dndState;
        this.option = ({ draggable: true });
        this.dndDragStart = new core.EventEmitter();
        this.dndDragEnd = new core.EventEmitter();
        this.dndCopied = new core.EventEmitter();
        this.dndLinked = new core.EventEmitter();
        this.dndMoved = new core.EventEmitter();
        this.dndCanceled = new core.EventEmitter();
        this.dndSelected = new core.EventEmitter();
        this.draggableString = 'draggable';
        this.dragState = dndState.dragState;
        this.nativeElement = element.nativeElement;
        this.nativeElement.setAttribute(this.draggableString, 'true');
        this.nativeElement.onselectstart = function () {
            if (this.dragDrop)
                this.dragDrop();
        };
    }
    Object.defineProperty(DndDraggable.prototype, "disableDrag", {
        set: function (disable) {
            if (disable !== undefined) {
                this.nativeElement.setAttribute(this.draggableString, (!disable).toString());
            }
        },
        enumerable: true,
        configurable: true
    });
    DndDraggable.prototype.ngOnInit = function () {
        var _this = this;
        this.dropSubscription = dropAccepted.subscribe(function (_a) {
            var item = _a.item, list = _a.list;
            if (JSON.stringify(_this.dndObject) === JSON.stringify(item)) {
                var cb = { copy: 'dndCopied', link: 'dndLinked', move: 'dndMoved', none: 'dndCanceled' };
                if (_this.dragState) {
                    ((_this[cb[_this.dragState.effectAllowed]])).emit();
                }
                _this.dndDragEnd.emit();
            }
        });
    };
    DndDraggable.prototype.ngOnDestroy = function () {
        this.dropSubscription.unsubscribe();
    };
    DndDraggable.prototype.handleDragStart = function (event) {
        var _this = this;
        if (this.nativeElement.getAttribute(this.draggableString) === 'false')
            return;
        this.dragState.isDragging = true;
        this.dragState.itemType = this.dndType;
        this.dragState.dropEffect = 'none';
        if (!this.option) {
            this.option = ({ draggable: true });
        }
        this.dragState.effectAllowed = this.option.effectAllowed || ALL_EFFECTS[0];
        event.dataTransfer.effectAllowed = this.dragState.effectAllowed;
        var mimeType = MIME_TYPE + (this.dragState.itemType ? ('-' + this.dragState.itemType) : '');
        try {
            event.dataTransfer.setData(mimeType, JSON.stringify(this.dndObject));
        }
        catch (e) {
            var data = JSON.stringify({ item: this.dndObject, type: this.dragState.itemType });
            try {
                event.dataTransfer.setData(EDGE_MIME_TYPE, data);
            }
            catch (e) {
                var effectsAllowed = this.dndState.filterEffects(ALL_EFFECTS, this.dragState.effectAllowed);
                event.dataTransfer.effectAllowed = effectsAllowed[0];
                event.dataTransfer.setData(MSIE_MIME_TYPE, data);
            }
        }
        this.nativeElement.classList.add('dndDragging');
        setTimeout(function () {
            if (_this.dragState.effectAllowed === 'move') {
                _this.nativeElement.style.display = 'none';
            }
        });
        if (((event))._dndHandle && event.dataTransfer.setDragImage) {
            event.dataTransfer.setDragImage(this.nativeElement, 0, 0);
        }
        this.dndDragStart.emit();
        event.stopPropagation();
    };
    DndDraggable.prototype.handleDragEnd = function (event) {
        var _this = this;
        this.dragState.isDragging = false;
        this.nativeElement.classList.remove('dndDragging');
        this.nativeElement.style.removeProperty('display');
        event.stopPropagation();
        setTimeout((function () { return _this.nativeElement.classList.remove('dndDraggingSource'); }), 0);
    };
    DndDraggable.prototype.handleClick = function (event) {
        if (this.nativeElement.hasAttribute('dndSelected'))
            return;
        event = event['originalEvent'] || event;
        this.dndSelected.emit();
        event.stopPropagation();
    };
    DndDraggable.prototype.findElementWithAttribute = function (element, attr) {
        if (element.hasAttribute(attr))
            return element;
        if (element.parentElement === null)
            return;
        return this.findElementWithAttribute(element.parentElement, attr);
    };
    return DndDraggable;
}());
DndDraggable.decorators = [
    { type: core.Directive, args: [{
                selector: '[dndDraggable]',
            },] },
];
DndDraggable.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: DndState, },
]; };
DndDraggable.propDecorators = {
    "option": [{ type: core.Input, args: ['dndDraggable',] },],
    "dndType": [{ type: core.Input, args: ['dndType',] },],
    "dndObject": [{ type: core.Input, args: ['dndObject',] },],
    "disableDrag": [{ type: core.Input, args: ['dndDragDisabled',] },],
    "dndDragStart": [{ type: core.Output, args: ['dndDragStart',] },],
    "dndDragEnd": [{ type: core.Output, args: ['dndDragEnd',] },],
    "dndCopied": [{ type: core.Output, args: ['dndCopied',] },],
    "dndLinked": [{ type: core.Output, args: ['dndLinked',] },],
    "dndMoved": [{ type: core.Output, args: ['dndMoved',] },],
    "dndCanceled": [{ type: core.Output, args: ['dndCanceled',] },],
    "dndSelected": [{ type: core.Output, args: ['dndSelected',] },],
    "handleDragStart": [{ type: core.HostListener, args: ['dragstart', ['$event'],] },],
    "handleDragEnd": [{ type: core.HostListener, args: ['dragend', ['$event'],] },],
    "handleClick": [{ type: core.HostListener, args: ['click', ['$event'],] },],
};
var DndNoDrag = /** @class */ (function () {
    function DndNoDrag(element, dndState) {
        this.element = element;
        this.dndState = dndState;
        this.draggableString = 'draggable';
        this.dragState = dndState.dragState;
        this.nativeElement = element.nativeElement;
        this.nativeElement.setAttribute(this.draggableString, 'true');
    }
    DndNoDrag.prototype.handleDragStart = function (event) {
        event = event['originalEvent'] || event;
        if (!event['_dndHandle']) {
            if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {
                event.preventDefault();
            }
            event.stopPropagation();
        }
    };
    DndNoDrag.prototype.handleDragEnd = function (event) {
        event = event['originalEvent'] || event;
        if (!event['_dndHandle']) {
            event.stopPropagation();
        }
    };
    return DndNoDrag;
}());
DndNoDrag.decorators = [
    { type: core.Directive, args: [{
                selector: '[dndNoDrag]',
            },] },
];
DndNoDrag.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: DndState, },
]; };
DndNoDrag.propDecorators = {
    "handleDragStart": [{ type: core.HostListener, args: ['dragstart', ['$event'],] },],
    "handleDragEnd": [{ type: core.HostListener, args: ['dragend', ['$event'],] },],
};
var DndHandle = /** @class */ (function () {
    function DndHandle(element, dndState) {
        this.element = element;
        this.dndState = dndState;
        this.draggableString = 'draggable';
        this.dragState = dndState.dragState;
        this.nativeElement = element.nativeElement;
        this.nativeElement.setAttribute(this.draggableString, 'true');
    }
    DndHandle.prototype.handleDragStart = function (event) {
        event = event['originalEvent'] || event;
        event['_dndHandle'] = true;
    };
    DndHandle.prototype.handleDragEnd = function (event) {
        event = event['originalEvent'] || event;
        if (!event['_dndHandle']) {
            event.stopPropagation();
        }
    };
    return DndHandle;
}());
DndHandle.decorators = [
    { type: core.Directive, args: [{
                selector: '[dndHandle]',
            },] },
];
DndHandle.ctorParameters = function () { return [
    { type: core.ElementRef, },
    { type: DndState, },
]; };
DndHandle.propDecorators = {
    "handleDragStart": [{ type: core.HostListener, args: ['dragstart', ['$event'],] },],
    "handleDragEnd": [{ type: core.HostListener, args: ['dragend', ['$event'],] },],
};
var DndListModule = /** @class */ (function () {
    function DndListModule() {
    }
    return DndListModule;
}());
DndListModule.decorators = [
    { type: core.NgModule, args: [{
                imports: [
                    common.CommonModule,
                ],
                exports: [
                    DndDraggable, DndHandle, DndList, DndNoDrag,
                ],
                entryComponents: [],
                declarations: [DndDraggable, DndHandle, DndList, DndNoDrag],
                providers: [
                    DndState,
                ],
            },] },
];

exports.DndListModule = DndListModule;
exports.DndDraggable = DndDraggable;
exports.DndNoDrag = DndNoDrag;
exports.dropAccepted = dropAccepted;
exports.DndList = DndList;
exports.DndHandle = DndHandle;
exports.MIME_TYPE = MIME_TYPE;
exports.EDGE_MIME_TYPE = EDGE_MIME_TYPE;
exports.MSIE_MIME_TYPE = MSIE_MIME_TYPE;
exports.ALL_EFFECTS = ALL_EFFECTS;
exports.DndState = DndState;
exports.ɵa = DndDraggable;
exports.ɵb = DndHandle;
exports.ɵc = DndList;
exports.ɵd = DndNoDrag;
exports.ɵe = DndState;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-drag-and-drop-lists.umd.js.map
