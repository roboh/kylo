{
  "version": 3,
  "file": "ngx-drag-and-drop-lists.umd.min.js",
  "sources": [
    "ng://ngx-drag-and-drop-lists/out/services/constants.ts",
    "ng://ngx-drag-and-drop-lists/out/services/DndState.ts",
    "ng://ngx-drag-and-drop-lists/out/directives/dnd-list.ts",
    "ng://ngx-drag-and-drop-lists/out/directives/dnd-draggable.ts",
    "ng://ngx-drag-and-drop-lists/out/directives/dnd-nodrag.ts",
    "ng://ngx-drag-and-drop-lists/out/directives/dnd-handle.ts",
    "ng://ngx-drag-and-drop-lists/out/module/module.ts"
  ],
  "sourcesContent": [
    "// In standard-compliant browsers we use a custom mime type and also encode the dnd-type in it.\n// However, IE and Edge only support a limited number of mime types. The workarounds are described\n// in https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\nexport const MIME_TYPE: string = 'application/x-dnd';\nexport const EDGE_MIME_TYPE: string = 'application/json';\nexport const MSIE_MIME_TYPE: string = 'Text';\n\n// All valid HTML5 drop effects, in the order in which we prefer to use them.\nexport const ALL_EFFECTS: Effects[] = ['move', 'copy', 'link'];\n\nexport type Effects = 'move' | 'copy' | 'link';\n",
    "import { Injectable } from '@angular/core';\nimport { ALL_EFFECTS, DndStateConfig } from '../index';\n@Injectable()\nexport class DndState {\n    public dragState: DndStateConfig = {\n        isDragging: false,\n        itemType: undefined,\n        dropEffect: 'none',\n        effectAllowed: ALL_EFFECTS[0],\n    };\n\n    /**\n     * Filters an array of drop effects using a HTML5 effectAllowed string.\n     */\n    public filterEffects(effects: string[], effectAllowed: string) {\n        if (effectAllowed === 'all') return effects;\n        return effects.filter((effect) => {\n            return effectAllowed.toLowerCase().indexOf(effect) !== -1;\n        });\n    }\n}\n",
    "import { Directive, Input, OnDestroy, OnInit, Output, ElementRef, HostListener, EventEmitter } from '@angular/core';\nimport {\n    DndState,\n    DndListSettings,\n    DndStateConfig,\n    ALL_EFFECTS,\n    MIME_TYPE,\n    EDGE_MIME_TYPE,\n    MSIE_MIME_TYPE,\n} from '../services';\nimport { Subject } from 'rxjs/Subject';\n\nexport const dropAccepted: Subject<any> = new Subject();\n\n@Directive({\n    selector: '[dndList]',\n})\nexport class DndList implements OnInit, OnDestroy {\n    @Input('dndList') public option: DndListSettings = {\n        disabled: false,\n        effectAllowed: 'move',\n        allowedTypes: undefined,\n    };\n    @Input('dndModel') public dndModel: any[];\n    @Input() public set dndPlaceholder(placeholder: Element) {\n        this.placeholder = placeholder;\n        placeholder.remove();\n    }\n    @Output('dndDragOver') public dndDragOver: EventEmitter<any> = new EventEmitter();\n    @Output('dndDrop') public dndDrop: EventEmitter<any> = new EventEmitter();\n    @Output('dndInserted') public dndInserted: EventEmitter<any> = new EventEmitter();\n    private dragState: DndStateConfig;\n    private nativeElement: HTMLElement;\n    private listSettings: {} = {};\n    private placeholder: Element;\n\n    constructor(\n        private element: ElementRef,\n        private dndState: DndState,\n    ) {\n        this.dragState = dndState.dragState;\n        this.nativeElement = element.nativeElement;\n        this.placeholder = this.getPlaceholderElement();\n    }\n\n    public ngOnInit(): void {\n        // placeholder\n    }\n\n    public ngOnDestroy(): void {\n        // placeholder\n    }\n\n    @HostListener('dragenter', ['$event'])\n    public handleDragEnter(event: DragEvent): boolean {\n        event = event['originalEvent'] || event;\n        const mimeType: string = this.getMimeType(event.dataTransfer.types);\n        if (!mimeType || !this.isDropAllowed(this.getItemType(mimeType))) {\n            return true;\n        }\n\n        event.preventDefault();\n        return false;\n    }\n\n    @HostListener('dragover', ['$event'])\n    public handleDragOver(event: DragEvent): boolean {\n        event = event['originalEvent'] || event;\n        const mimeType: string = this.getMimeType(event.dataTransfer.types);\n        const itemType: string = this.getItemType(mimeType);\n        if (!mimeType || !this.isDropAllowed(itemType)) {\n            return true;\n        }\n        // Make sure the placeholder is shown, which is especially important if the list is empty.\n        if (this.placeholder.parentNode !== this.nativeElement) {\n            this.nativeElement.appendChild(this.placeholder);\n        }\n\n        if (event.target !== this.nativeElement) {\n            // Try to find the node direct directly below the list node.\n            let listItemNode: Node = event.target as Node;\n            while (listItemNode.parentNode !== this.nativeElement && listItemNode.parentNode) {\n                listItemNode = listItemNode.parentNode;\n            }\n\n            if (listItemNode.parentNode === this.nativeElement && listItemNode !== this.placeholder) {\n                let isFirstHalf: boolean;\n                // If the mouse pointer is in the upper half of the list item element,\n                // we position the placeholder before the list item, otherwise after it.\n                const rect: ClientRect = (listItemNode as Element).getBoundingClientRect();\n                if (this.option && this.option.horizontal) {\n                    isFirstHalf = event.clientX < rect.left + rect.width / 2;\n                } else {\n                    isFirstHalf = event.clientY < rect.top + rect.height / 2;\n                }\n                this.nativeElement.insertBefore(\n                    this.placeholder,\n                    isFirstHalf ? listItemNode : listItemNode.nextSibling);\n            }\n        }\n\n        // In IE we set a fake effectAllowed in dragstart to get the correct cursor, we therefore\n        // ignore the effectAllowed passed in dataTransfer. We must also not access dataTransfer for\n        // drops from external sources, as that throws an exception.\n        let ignoreDataTransfer: boolean = mimeType === MSIE_MIME_TYPE;\n        let dropEffect: string = this.getDropEffect(event, ignoreDataTransfer);\n        if (dropEffect === 'none') return this.stopDragOver();\n\n        // At this point we invoke the callback, which still can disallow the drop.\n        // We can't do this earlier because we want to pass the index of the placeholder.\n        // if (this.dndDragOver &&\n        //     !this.invokeCallback(this.dndDragOver, event, dropEffect, itemType)) {\n        //     return this.stopDragOver();\n        // }\n\n        event.preventDefault();\n        if (!ignoreDataTransfer) {\n            event.dataTransfer.dropEffect = dropEffect;\n        }\n\n        this.nativeElement.classList.add('dndDragover');\n        event.stopPropagation();\n        return false;\n    }\n\n    @HostListener('drop', ['$event'])\n    public handleDrop(event: DragEvent): boolean {\n        event = event['originalEvent'] || event;\n\n        // Check whether the drop is allowed and determine mime type.\n        let mimeType: string = this.getMimeType(event.dataTransfer.types);\n        let itemType: string = this.getItemType(mimeType);\n        if (!mimeType || !this.isDropAllowed(itemType)) return true;\n\n        // The default behavior in Firefox is to interpret the dropped element as URL and\n        // forward to it. We want to prevent that even if our drop is aborted.\n        event.preventDefault();\n\n        let data: any = undefined;\n        // Unserialize the data that was serialized in dragstart.\n        try {\n            data = JSON.parse(event.dataTransfer.getData(mimeType));\n        } catch (e) {\n            return this.stopDragOver();\n        }\n\n        // Drops with invalid types from external sources might not have been filtered out yet.\n        if (mimeType === MSIE_MIME_TYPE || mimeType === EDGE_MIME_TYPE) {\n            itemType = data.type || undefined;\n            data = data.item;\n            if (!this.isDropAllowed(itemType)) return this.stopDragOver();\n        }\n\n        // Special handling for internal IE drops, see dragover handler.\n        let ignoreDataTransfer: boolean = mimeType === MSIE_MIME_TYPE;\n        let dropEffect: string = this.getDropEffect(event, ignoreDataTransfer);\n        if (dropEffect === 'none') return this.stopDragOver();\n\n        // Invoke the callback, which can transform the transferredObject and even abort the drop.\n        let index: number = this.getPlaceholderIndex();\n        // create an offset to account for extra elements (including the placeholder element)\n        let offset: number = this.nativeElement.children.length - 1 - this.dndModel.length;\n        if (this.dndDrop) {\n            this.invokeCallback(this.dndDrop, event, dropEffect, itemType, index, data);\n            if (!data) return this.stopDragOver();\n        }\n\n        // The drop is definitely going to happen now, store the dropEffect.\n        this.dragState.dropEffect = dropEffect;\n        if (!ignoreDataTransfer) {\n            event.dataTransfer.dropEffect = dropEffect;\n        }\n\n        // Insert the object into the array, unless dnd-drop took care of that (returned true).\n        if (data !== true) {\n            // use the offset to create an insertionPoint\n            let insertionPoint: number = index - offset;\n            if (insertionPoint < 0) {\n                insertionPoint = 0;\n            }\n            this.dndModel.splice(insertionPoint, 0, data);\n        }\n        this.invokeCallback(this.dndInserted, event, dropEffect, itemType, index, data);\n\n        // Tell old object to handle itself\n        dropAccepted.next({ item: data, list: this.dndModel });\n\n        // Clean up\n        this.stopDragOver();\n        event.stopPropagation();\n        return false;\n    }\n\n    @HostListener('dragleave', ['$event'])\n    public handleDragLeave(event: DragEvent): void {\n        event = event['originalEvent'] || event;\n\n        let newTarget: Element = document.elementFromPoint(event.clientX, event.clientY);\n        if (this.nativeElement.contains(newTarget) && !event['_dndPhShown']) {\n            // Signalize to potential parent lists that a placeholder is already shown.\n            event['_dndPhShown'] = true;\n        } else {\n            this.stopDragOver();\n        }\n    }\n\n    private getPlaceholderElement(): Element {\n        let placeholder: Element = undefined;\n        if (this.nativeElement.children) {\n            for (let i: number = 1; i < this.nativeElement.children.length; i++) {\n                let child: Element = this.nativeElement.children.item(i);\n                if (child.classList.contains('dndPlaceholder')) {\n                    placeholder = child;\n                }\n            }\n        }\n        let placeholderDefault: Element = document.createElement('li');\n        placeholderDefault.classList.add('dndPlaceholder');\n        return placeholder || placeholderDefault;\n    }\n\n    /**\n     * Given the types array from the DataTransfer object, returns the first valid mime type.\n     * A type is valid if it starts with MIME_TYPE, or it equals MSIE_MIME_TYPE or EDGE_MIME_TYPE.\n     */\n    private getMimeType(types: string[]): string {\n        if (!types) return MSIE_MIME_TYPE; // IE 9 workaround.\n        for (let i: number = 0; i < types.length; i++) {\n            if (types[i] === MSIE_MIME_TYPE || types[i] === EDGE_MIME_TYPE ||\n                types[i].substr(0, MIME_TYPE.length) === MIME_TYPE) {\n                return types[i];\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determines the type of the item from the dndState, or from the mime type for items from\n     * external sources. Returns undefined if no item type was set and null if the item type could\n     * not be determined.\n     */\n    private getItemType(mimeType: string): string {\n        if (this.dragState.isDragging) return this.dragState.itemType || undefined;\n        if (mimeType === MSIE_MIME_TYPE || mimeType === EDGE_MIME_TYPE) return null;\n        return (mimeType && mimeType.substr(MIME_TYPE.length + 1)) || undefined;\n    }\n\n    /**\n     * Checks various conditions that must be fulfilled for a drop to be allowed, including the\n     * dnd-allowed-types attribute. If the item Type is unknown (null), the drop will be allowed.\n     */\n    private isDropAllowed(itemType: string): boolean {\n        if (this.option) {\n            if (this.option.disabled) return false;\n            if (this.option.max && this.dndModel.length === this.option.max) return false;\n            if (!this.option.externalSources && !this.dragState.isDragging) return false;\n            if (!this.option.allowedTypes || itemType === null) return true;\n        }\n        return itemType && this.option.allowedTypes.indexOf(itemType) !== -1;\n    }\n\n    /**\n     * Determines which drop effect to use for the given event. In Internet Explorer we have to\n     * ignore the effectAllowed field on dataTransfer, since we set a fake value in dragstart.\n     * In those cases we rely on dndState to filter effects. Read the design doc for more details:\n     * https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n     */\n    private getDropEffect(event: DragEvent, ignoreDataTransfer: boolean): string {\n        let effects: string[] = Object.assign([], ALL_EFFECTS);\n        if (!ignoreDataTransfer) {\n            effects = this.dndState.filterEffects(effects, event.dataTransfer.effectAllowed);\n        }\n        if (this.dragState.isDragging) {\n            effects = this.dndState.filterEffects(effects, this.dragState.effectAllowed);\n        }\n        if (this.option && this.option.effectAllowed) {\n            effects = this.dndState.filterEffects(effects, this.option.effectAllowed);\n        }\n        // MacOS automatically filters dataTransfer.effectAllowed depending on the modifier keys,\n        // therefore the following modifier keys will only affect other operating systems.\n        if (!effects.length) {\n            return 'none';\n        } else if (event.ctrlKey && effects.indexOf('copy') !== -1) {\n            return 'copy';\n        } else if (event.altKey && effects.indexOf('link') !== -1) {\n            return 'link';\n        } else {\n            return effects[0];\n        }\n    }\n\n    /**\n     * Small helper function that cleans up if we aborted a drop.\n     */\n    private stopDragOver(): boolean {\n        this.placeholder.remove();\n        this.nativeElement.classList.remove('dndDragover');\n        return true;\n    }\n\n    /**\n     * Invokes a callback with some interesting parameters and returns the callbacks return value.\n     */\n    private invokeCallback(\n        eventEmitter: EventEmitter<any>,\n        event: DragEvent, dropEffect: string,\n        itemType: string, index?: number, item?: any): boolean {\n        eventEmitter.emit({\n            dropEffect: dropEffect,\n            event: event,\n            external: !this.dragState.isDragging,\n            index: index !== undefined ? index : this.getPlaceholderIndex(),\n            item: item || undefined,\n            type: itemType,\n        });\n        return true;\n    }\n    /**\n     * We use the position of the placeholder node to determine at which position of the array the\n     * object needs to be inserted\n     */\n    private getPlaceholderIndex(): number {\n        // Remove the dragging element to get the correct index of the placeholder;\n        for (let i: number = 0; i < this.nativeElement.children.length; i++) {\n            if (this.nativeElement.children[i].classList.contains('dndDragging')) {\n                this.nativeElement.children[i].remove();\n                break;\n            }\n        }\n        return Array.prototype.indexOf.call(this.nativeElement.children, this.placeholder);\n    }\n}\n",
    "import { Directive, Input, Output, OnDestroy, OnInit, ElementRef, HostListener, EventEmitter } from '@angular/core';\nimport { DndState } from '../services';\nimport {\n    DndDraggableConfig,\n    DndStateConfig,\n    ALL_EFFECTS,\n    MIME_TYPE,\n    EDGE_MIME_TYPE,\n    MSIE_MIME_TYPE,\n} from '../index';\nimport { dropAccepted } from './dnd-list';\nimport { Subscription } from 'rxjs/Subscription';\n@Directive({\n    selector: '[dndDraggable]',\n})\nexport class DndDraggable implements OnInit, OnDestroy {\n    @Input('dndDraggable') public option: DndDraggableConfig = <DndDraggableConfig>{ draggable: true };\n    @Input('dndType') public dndType: string;\n    @Input('dndObject') public dndObject: HTMLElement;\n    @Input('dndDragDisabled') public set disableDrag(disable: string | boolean) {\n        if (disable !== undefined) {\n            this.nativeElement.setAttribute(this.draggableString, (!disable).toString());\n        }\n    }\n    @Output('dndDragStart') public dndDragStart: EventEmitter<any> = new EventEmitter();\n    @Output('dndDragEnd') public dndDragEnd: EventEmitter<any> = new EventEmitter();\n    @Output('dndCopied') public dndCopied: EventEmitter<any> = new EventEmitter();\n    @Output('dndLinked') public dndLinked: EventEmitter<any> = new EventEmitter();\n    @Output('dndMoved') public dndMoved: EventEmitter<any> = new EventEmitter();\n    @Output('dndCanceled') public dndCanceled: EventEmitter<any> = new EventEmitter();\n    @Output('dndSelected') public dndSelected: EventEmitter<any> = new EventEmitter();\n\n    private dragState: DndStateConfig;\n    private dropSubscription: Subscription;\n    private nativeElement: HTMLElement;\n    private draggableString: string = 'draggable';\n    constructor(\n        private element: ElementRef,\n        private dndState: DndState,\n    ) {\n        this.dragState = dndState.dragState;\n        this.nativeElement = element.nativeElement;\n        this.nativeElement.setAttribute(this.draggableString, 'true');\n        /**\n         * Workaround to make element draggable in IE9\n         */\n        this.nativeElement.onselectstart = function (): void {\n            if (this.dragDrop) this.dragDrop();\n        };\n    }\n\n    public ngOnInit(): void {\n        this.dropSubscription = dropAccepted.subscribe(({ item, list }) => {\n            // event = event['originalEvent'] || event;\n            if (JSON.stringify(this.dndObject) === JSON.stringify(item)) {\n                let cb: object = { copy: 'dndCopied', link: 'dndLinked', move: 'dndMoved', none: 'dndCanceled' };\n                if (this.dragState) {\n                    (this[cb[this.dragState.effectAllowed]] as EventEmitter<any>).emit();\n                }\n                this.dndDragEnd.emit();\n            }\n        });\n    }\n\n    public ngOnDestroy(): void {\n        this.dropSubscription.unsubscribe();\n    }\n\n    @HostListener('dragstart', ['$event'])\n    public handleDragStart(event: DragEvent): void {\n\n        // disabled check\n        if (this.nativeElement.getAttribute(this.draggableString) === 'false')\n            return;\n\n        // init drag\n        this.dragState.isDragging = true;\n        this.dragState.itemType = this.dndType;\n        this.dragState.dropEffect = 'none';\n        if (!this.option) {\n            this.option = <DndDraggableConfig>{ draggable: true };\n        }\n        this.dragState.effectAllowed = this.option.effectAllowed || ALL_EFFECTS[0];\n        event.dataTransfer.effectAllowed = this.dragState.effectAllowed;\n        // Internet Explorer and Microsoft Edge don't support custom mime types, see design doc:\n        // https://github.com/marceljuenemann/angular-drag-and-drop-lists/wiki/Data-Transfer-Design\n        let mimeType: string = MIME_TYPE + (this.dragState.itemType ? ('-' + this.dragState.itemType) : '');\n        try {\n            event.dataTransfer.setData(mimeType, JSON.stringify(this.dndObject));\n        } catch (e) {\n            // Setting a custom MIME type did not work, we are probably in IE or Edge.\n            let data: string = JSON.stringify({ item: this.dndObject, type: this.dragState.itemType });\n            try {\n                event.dataTransfer.setData(EDGE_MIME_TYPE, data);\n            } catch (e) {\n                // We are in Internet Explorer and can only use the Text MIME type. Also note that IE\n                // does not allow changing the cursor in the dragover event, therefore we have to choose\n                // the one we want to display now by setting effectAllowed.\n                let effectsAllowed: string[] = this.dndState.filterEffects(ALL_EFFECTS, this.dragState.effectAllowed);\n                event.dataTransfer.effectAllowed = effectsAllowed[0];\n                event.dataTransfer.setData(MSIE_MIME_TYPE, data);\n            }\n        }\n\n        // add drag classes\n        this.nativeElement.classList.add('dndDragging');\n        setTimeout(\n            () => {\n                if (this.dragState.effectAllowed === 'move') {\n                    this.nativeElement.style.display = 'none';\n                }\n            });\n\n        // Try setting a proper drag image if triggered on a dnd-handle (won't work in IE).\n        if ((<any>event)._dndHandle && event.dataTransfer.setDragImage) {\n            event.dataTransfer.setDragImage(this.nativeElement, 0, 0);\n        }\n\n        this.dndDragStart.emit();\n        event.stopPropagation();\n    }\n\n    @HostListener('dragend', ['$event'])\n    public handleDragEnd(event: DragEvent): void {\n        // Clean up\n        this.dragState.isDragging = false;\n        this.nativeElement.classList.remove('dndDragging');\n        this.nativeElement.style.removeProperty('display');\n        event.stopPropagation();\n        // In IE9 it is possible that the timeout from dragstart triggers after the dragend handler.\n        setTimeout((() => this.nativeElement.classList.remove('dndDraggingSource')), 0);\n    }\n\n    @HostListener('click', ['$event'])\n    public handleClick(event: Event): void {\n\n        if (this.nativeElement.hasAttribute('dndSelected')) return;\n\n        event = event['originalEvent'] || event;\n\n        this.dndSelected.emit();\n\n        event.stopPropagation();\n    }\n\n    private findElementWithAttribute(element: HTMLElement, attr: string): HTMLElement {\n        if (element.hasAttribute(attr)) return element;\n        if (element.parentElement === null) return;\n        return this.findElementWithAttribute(element.parentElement, attr);\n    }\n\n}\n",
    "import { Directive, Input, Output, ElementRef, HostListener, EventEmitter } from '@angular/core';\nimport {\n    DndState,\n    DndDraggableConfig,\n    DndStateConfig,\n} from '../services';\n@Directive({\n    selector: '[dndNoDrag]',\n})\n/**\n * Use the dnd-nodrag attribute inside of dnd-draggable elements to prevent them from starting\n * drag operations. This is especially useful if you want to use input elements inside of\n * dnd-draggable elements or create specific handle elements. Note: This directive does not work\n * in Internet Explorer 9.\n */\nexport class DndNoDrag {\n    private dragState: DndStateConfig;\n    private nativeElement: HTMLElement;\n    private draggableString: string = 'draggable';\n    constructor(\n        private element: ElementRef,\n        private dndState: DndState,\n    ) {\n        this.dragState = dndState.dragState;\n        this.nativeElement = element.nativeElement;\n        this.nativeElement.setAttribute(this.draggableString, 'true');\n\n    }\n\n    @HostListener('dragstart', ['$event'])\n    public handleDragStart(event: DragEvent): void {\n        event = event['originalEvent'] || event;\n\n        if (!event['_dndHandle']) {\n            // If a child element already reacted to dragstart and set a dataTransfer object, we will\n            // allow that. For example, this is the case for user selections inside of input elements.\n            if (!(event.dataTransfer.types && event.dataTransfer.types.length)) {\n                event.preventDefault();\n            }\n            event.stopPropagation();\n        }\n    }\n\n    @HostListener('dragend', ['$event'])\n    public handleDragEnd(event: DragEvent): void {\n        event = event['originalEvent'] || event;\n\n        if (!event['_dndHandle']) {\n            event.stopPropagation();\n        }\n    }\n}\n",
    "import { Directive, Input, Output, ElementRef, HostListener, EventEmitter } from '@angular/core';\nimport {\n    DndState,\n    DndDraggableConfig,\n    DndStateConfig,\n} from '../services';\n@Directive({\n    selector: '[dndHandle]',\n})\n/**\n * Use the dnd-handle directive within a dnd-nodrag element in order to allow dragging with that\n * element after all. Therefore, by combining dnd-nodrag and dnd-handle you can allow\n * dnd-draggable elements to only be dragged via specific \"handle\" elements. Note that Internet\n * Explorer will show the handle element as drag image instead of the dnd-draggable element. You\n * can work around this by styling the handle element differently when it is being dragged. Use\n * the CSS selector .dndDragging:not(.dndDraggingSource) [dnd-handle] for that.\n */\nexport class DndHandle {\n    private dragState: DndStateConfig;\n    private nativeElement: HTMLElement;\n    private draggableString: string = 'draggable';\n    constructor(\n        private element: ElementRef,\n        private dndState: DndState,\n    ) {\n        this.dragState = dndState.dragState;\n        this.nativeElement = element.nativeElement;\n        this.nativeElement.setAttribute(this.draggableString, 'true');\n\n    }\n\n    @HostListener('dragstart', ['$event'])\n    public handleDragStart(event: DragEvent): void {\n        event = event['originalEvent'] || event;\n        event['_dndHandle'] = true;\n    }\n\n    @HostListener('dragend', ['$event'])\n    public handleDragEnd(event: DragEvent): void {\n        event = event['originalEvent'] || event;\n\n        if (!event['_dndHandle']) {\n            event.stopPropagation();\n        }\n    }\n}\n",
    "import { NgModule } from '@angular/core';\nimport { DndDraggable, DndHandle, DndList, DndNoDrag } from '../directives';\nimport { DndState } from '../services';\nimport { CommonModule } from '@angular/common';\n\n@NgModule({\n    imports: [\n        CommonModule,\n    ],\n    exports: [\n        DndDraggable, DndHandle, DndList, DndNoDrag,\n    ],\n    entryComponents: [],\n    declarations: [DndDraggable, DndHandle, DndList, DndNoDrag],\n    providers: [\n        DndState,\n    ],\n})\nexport class DndListModule {\n}\n\n"
  ],
  "names": [
    "MIME_TYPE",
    "EDGE_MIME_TYPE",
    "MSIE_MIME_TYPE",
    "ALL_EFFECTS",
    "DndState",
    "this",
    "dragState",
    "isDragging",
    "itemType",
    "undefined",
    "dropEffect",
    "effectAllowed",
    "prototype",
    "filterEffects",
    "effects",
    "filter",
    "effect",
    "toLowerCase",
    "indexOf",
    "type",
    "Injectable",
    "dropAccepted",
    "Subject",
    "DndList",
    "element",
    "dndState",
    "option",
    "disabled",
    "allowedTypes",
    "dndDragOver",
    "EventEmitter",
    "dndDrop",
    "dndInserted",
    "listSettings",
    "nativeElement",
    "placeholder",
    "getPlaceholderElement",
    "Object",
    "defineProperty",
    "set",
    "remove",
    "ngOnInit",
    "ngOnDestroy",
    "handleDragEnter",
    "event",
    "mimeType",
    "getMimeType",
    "dataTransfer",
    "types",
    "isDropAllowed",
    "getItemType",
    "preventDefault",
    "handleDragOver",
    "parentNode",
    "appendChild",
    "target",
    "listItemNode",
    "isFirstHalf",
    "rect",
    "getBoundingClientRect",
    "horizontal",
    "clientX",
    "left",
    "width",
    "clientY",
    "top",
    "height",
    "insertBefore",
    "nextSibling",
    "ignoreDataTransfer",
    "getDropEffect",
    "stopDragOver",
    "classList",
    "add",
    "stopPropagation",
    "handleDrop",
    "data",
    "JSON",
    "parse",
    "getData",
    "e",
    "item",
    "index",
    "getPlaceholderIndex",
    "offset",
    "children",
    "length",
    "dndModel",
    "invokeCallback",
    "insertionPoint",
    "splice",
    "next",
    "list",
    "handleDragLeave",
    "newTarget",
    "document",
    "elementFromPoint",
    "contains",
    "i",
    "child",
    "placeholderDefault",
    "createElement",
    "substr",
    "max",
    "externalSources",
    "assign",
    "ctrlKey",
    "altKey",
    "eventEmitter",
    "emit",
    "external",
    "Array",
    "call",
    "Directive",
    "args",
    "selector",
    "ElementRef",
    "Input",
    "dndPlaceholder",
    "Output",
    "HostListener",
    "DndDraggable",
    "draggable",
    "dndDragStart",
    "dndDragEnd",
    "dndCopied",
    "dndLinked",
    "dndMoved",
    "dndCanceled",
    "dndSelected",
    "draggableString",
    "setAttribute",
    "onselectstart",
    "dragDrop",
    "disable",
    "toString",
    "_this",
    "dropSubscription",
    "subscribe",
    "_a",
    "stringify",
    "dndObject",
    "copy",
    "link",
    "move",
    "none",
    "unsubscribe",
    "handleDragStart",
    "getAttribute",
    "dndType",
    "setData",
    "effectsAllowed",
    "setTimeout",
    "style",
    "display",
    "_dndHandle",
    "setDragImage",
    "handleDragEnd",
    "removeProperty",
    "handleClick",
    "hasAttribute",
    "findElementWithAttribute",
    "attr",
    "parentElement",
    "disableDrag",
    "DndNoDrag",
    "DndHandle",
    "DndListModule",
    "NgModule",
    "imports",
    "CommonModule",
    "exports",
    "entryComponents",
    "declarations",
    "providers"
  ],
  "mappings": "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"
}
